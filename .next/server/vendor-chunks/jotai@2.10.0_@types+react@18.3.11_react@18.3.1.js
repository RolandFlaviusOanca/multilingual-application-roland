"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai@2.10.0_@types+react@18.3.11_react@18.3.1";
exports.ids = ["vendor-chunks/jotai@2.10.0_@types+react@18.3.11_react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/react.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/react.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1_sass@1.79.4/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseMeta = (promise)=>{\n    promise.status = \"pending\";\n    promise.then((v)=>{\n        promise.status = \"fulfilled\";\n        promise.value = v;\n    }, (e)=>{\n        promise.status = \"rejected\";\n        promise.reason = e;\n    });\n};\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        attachPromiseMeta(promise);\n        throw promise;\n    }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise)=>{\n    let continuablePromise = continuablePromiseMap.get(promise);\n    if (!continuablePromise) {\n        continuablePromise = new Promise((resolve, reject)=>{\n            let curr = promise;\n            const onFulfilled = (me)=>(v)=>{\n                    if (curr === me) {\n                        resolve(v);\n                    }\n                };\n            const onRejected = (me)=>(e)=>{\n                    if (curr === me) {\n                        reject(e);\n                    }\n                };\n            const registerCancelHandler = (p)=>{\n                if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\n                    p.onCancel((nextValue)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && nextValue === p) {\n                            throw new Error(\"[Bug] p is not updated even after cancelation\");\n                        }\n                        if (isPromiseLike(nextValue)) {\n                            continuablePromiseMap.set(nextValue, continuablePromise);\n                            curr = nextValue;\n                            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n                            registerCancelHandler(nextValue);\n                        } else {\n                            resolve(nextValue);\n                        }\n                    });\n                }\n            };\n            promise.then(onFulfilled(promise), onRejected(promise));\n            registerCancelHandler(promise);\n        });\n        continuablePromiseMap.set(promise, continuablePromise);\n    }\n    return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                const value2 = store.get(atom);\n                if (isPromiseLike(value2)) {\n                    attachPromiseMeta(createContinuablePromise(value2));\n                }\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    if (isPromiseLike(value)) {\n        const promise = createContinuablePromise(value);\n        return use(promise);\n    }\n    return value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vam90YWlAMi4xMC4wX0B0eXBlcytyZWFjdEAxOC4zLjExX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3VHQUMwSTtBQUM3RTtBQUU3RCxNQUFNVyw2QkFBZVYsb0RBQWFBLENBQ2hDLEtBQUs7QUFFUCxNQUFNVyxXQUFXLENBQUNDO0lBQ2hCLE1BQU1DLFFBQVFaLGlEQUFVQSxDQUFDUztJQUN6QixPQUFPLENBQUNFLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLEtBQUssS0FBS0EsU0FBU0wsOERBQWVBO0FBQy9FO0FBQ0EsTUFBTU0sV0FBVyxDQUFDLEVBQ2hCQyxRQUFRLEVBQ1JGLEtBQUssRUFDTjtJQUNDLE1BQU1HLFdBQVdkLDZDQUFNQTtJQUN2QixJQUFJLENBQUNXLFNBQVMsQ0FBQ0csU0FBU0MsT0FBTyxFQUFFO1FBQy9CRCxTQUFTQyxPQUFPLEdBQUdSLDBEQUFXQTtJQUNoQztJQUNBLHFCQUFPTixvREFBYUEsQ0FDbEJPLGFBQWFJLFFBQVEsRUFDckI7UUFDRUksT0FBT0wsU0FBU0csU0FBU0MsT0FBTztJQUNsQyxHQUNBRjtBQUVKO0FBRUEsTUFBTUksZ0JBQWdCLENBQUNDLElBQU0sT0FBUUEsQ0FBQUEsS0FBSyxPQUFPLEtBQUssSUFBSUEsRUFBRUMsSUFBSSxNQUFNO0FBQ3RFLE1BQU1DLG9CQUFvQixDQUFDQztJQUN6QkEsUUFBUUMsTUFBTSxHQUFHO0lBQ2pCRCxRQUFRRixJQUFJLENBQ1YsQ0FBQ0k7UUFDQ0YsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRTCxLQUFLLEdBQUdPO0lBQ2xCLEdBQ0EsQ0FBQ0M7UUFDQ0gsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRSSxNQUFNLEdBQUdEO0lBQ25CO0FBRUo7QUFDQSxNQUFNRSxNQUFNN0Isc0NBQWdCLElBQUssRUFBQ3dCO0lBQ2hDLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxXQUFXO1FBQ2hDLE1BQU1EO0lBQ1IsT0FBTyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssYUFBYTtRQUN6QyxPQUFPRCxRQUFRTCxLQUFLO0lBQ3RCLE9BQU8sSUFBSUssUUFBUUMsTUFBTSxLQUFLLFlBQVk7UUFDeEMsTUFBTUQsUUFBUUksTUFBTTtJQUN0QixPQUFPO1FBQ0xMLGtCQUFrQkM7UUFDbEIsTUFBTUE7SUFDUjtBQUNGO0FBQ0EsTUFBTU0sd0JBQXdCLGFBQWEsR0FBRyxJQUFJQztBQUNsRCxNQUFNQywyQkFBMkIsQ0FBQ1I7SUFDaEMsSUFBSVMscUJBQXFCSCxzQkFBc0JJLEdBQUcsQ0FBQ1Y7SUFDbkQsSUFBSSxDQUFDUyxvQkFBb0I7UUFDdkJBLHFCQUFxQixJQUFJRSxRQUFRLENBQUNDLFNBQVNDO1lBQ3pDLElBQUlDLE9BQU9kO1lBQ1gsTUFBTWUsY0FBYyxDQUFDQyxLQUFPLENBQUNkO29CQUMzQixJQUFJWSxTQUFTRSxJQUFJO3dCQUNmSixRQUFRVjtvQkFDVjtnQkFDRjtZQUNBLE1BQU1lLGFBQWEsQ0FBQ0QsS0FBTyxDQUFDYjtvQkFDMUIsSUFBSVcsU0FBU0UsSUFBSTt3QkFDZkgsT0FBT1Y7b0JBQ1Q7Z0JBQ0Y7WUFDQSxNQUFNZSx3QkFBd0IsQ0FBQ0M7Z0JBQzdCLElBQUksY0FBY0EsS0FBSyxPQUFPQSxFQUFFQyxRQUFRLEtBQUssWUFBWTtvQkFDdkRELEVBQUVDLFFBQVEsQ0FBQyxDQUFDQzt3QkFDVixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQkEsY0FBY0YsR0FBRzs0QkFDekYsTUFBTSxJQUFJSyxNQUFNO3dCQUNsQjt3QkFDQSxJQUFJNUIsY0FBY3lCLFlBQVk7NEJBQzVCZixzQkFBc0JtQixHQUFHLENBQUNKLFdBQVdaOzRCQUNyQ0ssT0FBT087NEJBQ1BBLFVBQVV2QixJQUFJLENBQUNpQixZQUFZTSxZQUFZSixXQUFXSTs0QkFDbERILHNCQUFzQkc7d0JBQ3hCLE9BQU87NEJBQ0xULFFBQVFTO3dCQUNWO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQXJCLFFBQVFGLElBQUksQ0FBQ2lCLFlBQVlmLFVBQVVpQixXQUFXakI7WUFDOUNrQixzQkFBc0JsQjtRQUN4QjtRQUNBTSxzQkFBc0JtQixHQUFHLENBQUN6QixTQUFTUztJQUNyQztJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTaUIsYUFBYUMsSUFBSSxFQUFFdEMsT0FBTztJQUNqQyxNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNLENBQUMsQ0FBQ3VDLGtCQUFrQkMsa0JBQWtCQyxnQkFBZ0IsRUFBRUMsU0FBUyxHQUFHbEQsaURBQVVBLENBQ2xGLENBQUNtRDtRQUNDLE1BQU1YLFlBQVkvQixNQUFNb0IsR0FBRyxDQUFDaUI7UUFDNUIsSUFBSU0sT0FBT0MsRUFBRSxDQUFDRixJQUFJLENBQUMsRUFBRSxFQUFFWCxjQUFjVyxJQUFJLENBQUMsRUFBRSxLQUFLMUMsU0FBUzBDLElBQUksQ0FBQyxFQUFFLEtBQUtMLE1BQU07WUFDMUUsT0FBT0s7UUFDVDtRQUNBLE9BQU87WUFBQ1g7WUFBVy9CO1lBQU9xQztTQUFLO0lBQ2pDLEdBQ0EsS0FBSyxHQUNMLElBQU07WUFBQ3JDLE1BQU1vQixHQUFHLENBQUNpQjtZQUFPckM7WUFBT3FDO1NBQUs7SUFFdEMsSUFBSWhDLFFBQVFpQztJQUNaLElBQUlDLHFCQUFxQnZDLFNBQVN3QyxvQkFBb0JILE1BQU07UUFDMURJO1FBQ0FwQyxRQUFRTCxNQUFNb0IsR0FBRyxDQUFDaUI7SUFDcEI7SUFDQSxNQUFNUSxRQUFROUMsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUThDLEtBQUs7SUFDdERyRCxnREFBU0EsQ0FBQztRQUNSLE1BQU1zRCxRQUFROUMsTUFBTStDLEdBQUcsQ0FBQ1YsTUFBTTtZQUM1QixJQUFJLE9BQU9RLFVBQVUsVUFBVTtnQkFDN0IsTUFBTUcsU0FBU2hELE1BQU1vQixHQUFHLENBQUNpQjtnQkFDekIsSUFBSS9CLGNBQWMwQyxTQUFTO29CQUN6QnZDLGtCQUFrQlMseUJBQXlCOEI7Z0JBQzdDO2dCQUNBQyxXQUFXUixVQUFVSTtnQkFDckI7WUFDRjtZQUNBSjtRQUNGO1FBQ0FBO1FBQ0EsT0FBT0s7SUFDVCxHQUFHO1FBQUM5QztRQUFPcUM7UUFBTVE7S0FBTTtJQUN2QnBELG9EQUFhQSxDQUFDWTtJQUNkLElBQUlDLGNBQWNELFFBQVE7UUFDeEIsTUFBTUssVUFBVVEseUJBQXlCYjtRQUN6QyxPQUFPVSxJQUFJTDtJQUNiO0lBQ0EsT0FBT0w7QUFDVDtBQUVBLFNBQVM2QyxXQUFXYixJQUFJLEVBQUV0QyxPQUFPO0lBQy9CLE1BQU1DLFFBQVFGLFNBQVNDO0lBQ3ZCLE1BQU1vRCxVQUFVekQsa0RBQVdBLENBQ3pCLENBQUMsR0FBRzBEO1FBQ0YsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0IsQ0FBRSxZQUFXZixJQUFHLEdBQUk7WUFDNUYsTUFBTSxJQUFJSCxNQUFNO1FBQ2xCO1FBQ0EsT0FBT2xDLE1BQU1tQyxHQUFHLENBQUNFLFNBQVNlO0lBQzVCLEdBQ0E7UUFBQ3BEO1FBQU9xQztLQUFLO0lBRWYsT0FBT2M7QUFDVDtBQUVBLFNBQVNFLFFBQVFoQixJQUFJLEVBQUV0QyxPQUFPO0lBQzVCLE9BQU87UUFDTHFDLGFBQWFDLE1BQU10QztRQUNuQix1RUFBdUU7UUFDdkVtRCxXQUFXYixNQUFNdEM7S0FDbEI7QUFDSDtBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovL211bHRpbGluZ3VhbC1hcHAvLi9ub2RlX21vZHVsZXMvLnBucG0vam90YWlAMi4xMC4wX0B0eXBlcytyZWFjdEAxOC4zLjExX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcz83MWUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdEV4cG9ydHMsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVmLCBjcmVhdGVFbGVtZW50LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIHVzZURlYnVnVmFsdWUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFN0b3JlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEnO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFxuICB2b2lkIDBcbik7XG5jb25zdCB1c2VTdG9yZSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmUpIHx8IHN0b3JlIHx8IGdldERlZmF1bHRTdG9yZSgpO1xufTtcbmNvbnN0IFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIHN0b3JlXG59KSA9PiB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlUmVmKCk7XG4gIGlmICghc3RvcmUgJiYgIXN0b3JlUmVmLmN1cnJlbnQpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBTdG9yZUNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHN0b3JlIHx8IHN0b3JlUmVmLmN1cnJlbnRcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59O1xuXG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgYXR0YWNoUHJvbWlzZU1ldGEgPSAocHJvbWlzZSkgPT4ge1xuICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICBwcm9taXNlLnRoZW4oXG4gICAgKHYpID0+IHtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgIH0sXG4gICAgKGUpID0+IHtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgIH1cbiAgKTtcbn07XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSkgPT4ge1xuICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgfSBlbHNlIHtcbiAgICBhdHRhY2hQcm9taXNlTWV0YShwcm9taXNlKTtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59KTtcbmNvbnN0IGNvbnRpbnVhYmxlUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgY3JlYXRlQ29udGludWFibGVQcm9taXNlID0gKHByb21pc2UpID0+IHtcbiAgbGV0IGNvbnRpbnVhYmxlUHJvbWlzZSA9IGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG4gIGlmICghY29udGludWFibGVQcm9taXNlKSB7XG4gICAgY29udGludWFibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGN1cnIgPSBwcm9taXNlO1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSAobWUpID0+ICh2KSA9PiB7XG4gICAgICAgIGlmIChjdXJyID09PSBtZSkge1xuICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gKG1lKSA9PiAoZSkgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZWdpc3RlckNhbmNlbEhhbmRsZXIgPSAocCkgPT4ge1xuICAgICAgICBpZiAoXCJvbkNhbmNlbFwiIGluIHAgJiYgdHlwZW9mIHAub25DYW5jZWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHAub25DYW5jZWwoKG5leHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIG5leHRWYWx1ZSA9PT0gcCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQnVnXSBwIGlzIG5vdCB1cGRhdGVkIGV2ZW4gYWZ0ZXIgY2FuY2VsYXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQobmV4dFZhbHVlLCBjb250aW51YWJsZVByb21pc2UpO1xuICAgICAgICAgICAgICBjdXJyID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICBuZXh0VmFsdWUudGhlbihvbkZ1bGZpbGxlZChuZXh0VmFsdWUpLCBvblJlamVjdGVkKG5leHRWYWx1ZSkpO1xuICAgICAgICAgICAgICByZWdpc3RlckNhbmNlbEhhbmRsZXIobmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHByb21pc2UudGhlbihvbkZ1bGZpbGxlZChwcm9taXNlKSwgb25SZWplY3RlZChwcm9taXNlKSk7XG4gICAgICByZWdpc3RlckNhbmNlbEhhbmRsZXIocHJvbWlzZSk7XG4gICAgfSk7XG4gICAgY29udGludWFibGVQcm9taXNlTWFwLnNldChwcm9taXNlLCBjb250aW51YWJsZVByb21pc2UpO1xuICB9XG4gIHJldHVybiBjb250aW51YWJsZVByb21pc2U7XG59O1xuZnVuY3Rpb24gdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3QgW1t2YWx1ZUZyb21SZWR1Y2VyLCBzdG9yZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcl0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICBpZiAoT2JqZWN0LmlzKHByZXZbMF0sIG5leHRWYWx1ZSkgJiYgcHJldlsxXSA9PT0gc3RvcmUgJiYgcHJldlsyXSA9PT0gYXRvbSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV4dFZhbHVlLCBzdG9yZSwgYXRvbV07XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgKCkgPT4gW3N0b3JlLmdldChhdG9tKSwgc3RvcmUsIGF0b21dXG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChzdG9yZUZyb21SZWR1Y2VyICE9PSBzdG9yZSB8fCBhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcigpO1xuICAgIHZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YihhdG9tLCAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUyKSkge1xuICAgICAgICAgIGF0dGFjaFByb21pc2VNZXRhKGNyZWF0ZUNvbnRpbnVhYmxlUHJvbWlzZSh2YWx1ZTIpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KHJlcmVuZGVyLCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgfSk7XG4gICAgcmVyZW5kZXIoKTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH0sIFtzdG9yZSwgYXRvbSwgZGVsYXldKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVDb250aW51YWJsZVByb21pc2UodmFsdWUpO1xuICAgIHJldHVybiB1c2UocHJvbWlzZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuc2V0KGF0b20sIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW3N0b3JlLCBhdG9tXVxuICApO1xuICByZXR1cm4gc2V0QXRvbTtcbn1cblxuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpLFxuICAgIC8vIFdlIGRvIHdyb25nIHR5cGUgYXNzZXJ0aW9uIGhlcmUsIHdoaWNoIHJlc3VsdHMgaW4gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKVxuICBdO1xufVxuXG5leHBvcnQgeyBQcm92aWRlciwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0RXhwb3J0cyIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlQ2FsbGJhY2siLCJnZXREZWZhdWx0U3RvcmUiLCJjcmVhdGVTdG9yZSIsIlN0b3JlQ29udGV4dCIsInVzZVN0b3JlIiwib3B0aW9ucyIsInN0b3JlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN0b3JlUmVmIiwiY3VycmVudCIsInZhbHVlIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwiYXR0YWNoUHJvbWlzZU1ldGEiLCJwcm9taXNlIiwic3RhdHVzIiwidiIsImUiLCJyZWFzb24iLCJ1c2UiLCJjb250aW51YWJsZVByb21pc2VNYXAiLCJXZWFrTWFwIiwiY3JlYXRlQ29udGludWFibGVQcm9taXNlIiwiY29udGludWFibGVQcm9taXNlIiwiZ2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjdXJyIiwib25GdWxmaWxsZWQiLCJtZSIsIm9uUmVqZWN0ZWQiLCJyZWdpc3RlckNhbmNlbEhhbmRsZXIiLCJwIiwib25DYW5jZWwiLCJuZXh0VmFsdWUiLCJlbnYiLCJNT0RFIiwiRXJyb3IiLCJzZXQiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJ2YWx1ZTIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/vanilla.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/vanilla.mjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return ( false ? 0 : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? void 0 : _a[1]);\n};\nconst cancelPromise = (promise, nextValue) => {\n  const promiseState = cancelablePromiseMap.get(promise);\n  if (promiseState) {\n    promiseState[1] = true;\n    promiseState[0].forEach((fn) => fn(nextValue));\n  } else if (( false ? 0 : void 0) !== \"production\") {\n    throw new Error(\"[Bug] cancelable promise not found\");\n  }\n};\nconst patchPromiseForCancelability = (promise) => {\n  if (cancelablePromiseMap.has(promise)) {\n    return;\n  }\n  const promiseState = [/* @__PURE__ */ new Set(), false];\n  cancelablePromiseMap.set(promise, promiseState);\n  const settle = () => {\n    promiseState[1] = true;\n  };\n  promise.then(settle, settle);\n  promise.onCancel = (fn) => {\n    promiseState[0].add(fn);\n  };\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if (( false ? 0 : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst addDependency = (pending, atom, atomState, a, aState) => {\n  var _a;\n  if (( false ? 0 : void 0) !== \"production\" && a === atom) {\n    throw new Error(\"[Bug] atom cannot depend on itself\");\n  }\n  atomState.d.set(a, aState.n);\n  if (isPendingPromise(atomState.v)) {\n    addPendingPromiseToDependency(atom, atomState.v, aState);\n  }\n  (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n  if (pending) {\n    addPendingDependent(pending, a, atom);\n  }\n};\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\nconst addPendingAtom = (pending, atom, atomState) => {\n  if (!pending[0].has(atom)) {\n    pending[0].set(atom, /* @__PURE__ */ new Set());\n  }\n  pending[1].set(atom, atomState);\n};\nconst addPendingDependent = (pending, atom, dependent) => {\n  const dependents = pending[0].get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\nconst addPendingFunction = (pending, fn) => {\n  pending[2].add(fn);\n};\nconst flushPending = (pending) => {\n  while (pending[1].size || pending[2].size) {\n    pending[0].clear();\n    const atomStates = new Set(pending[1].values());\n    pending[1].clear();\n    const functions = new Set(pending[2]);\n    pending[2].clear();\n    atomStates.forEach((atomState) => {\n      var _a;\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach((l) => l());\n    });\n    functions.forEach((fn) => fn());\n  }\n};\nconst buildStore = (getAtomState) => {\n  let debugMountedAtoms;\n  if (( false ? 0 : void 0) !== \"production\") {\n    debugMountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;\n    if (isPromiseLike(valueOrPromise)) {\n      patchPromiseForCancelability(valueOrPromise);\n      for (const a of atomState.d.keys()) {\n        addPendingPromiseToDependency(\n          atom,\n          valueOrPromise,\n          getAtomState(a, atomState)\n        );\n      }\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    } else {\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    }\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n      if (pendingPromise) {\n        cancelPromise(pendingPromise, valueOrPromise);\n      }\n    }\n  };\n  const readAtomState = (pending, atom, atomState, force) => {\n    var _a;\n    if (!(force == null ? void 0 : force(atom)) && isAtomStateInitialized(atomState)) {\n      if (atomState.m) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(pending, a, getAtomState(a, atomState), force).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a, atomState);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(\n        pending,\n        a,\n        getAtomState(a, atomState),\n        force\n      );\n      if (isSync) {\n        addDependency(pending, atom, atomState, a, aState);\n      } else {\n        const pending2 = createPending();\n        addDependency(pending2, atom, atomState, a, aState);\n        mountDependencies(pending2, atom, atomState);\n        flushPending(pending2);\n      }\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      setAtomStateValueOrPromise(atom, atomState, valueOrPromise);\n      if (isPromiseLike(valueOrPromise)) {\n        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        const complete = () => {\n          if (atomState.m) {\n            const pending2 = createPending();\n            mountDependencies(pending2, atom, atomState);\n            flushPending(pending2);\n          }\n        };\n        valueOrPromise.then(complete, complete);\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom, getAtomState(atom)));\n  const getDependents = (pending, atom, atomState) => {\n    var _a, _b;\n    const dependents = /* @__PURE__ */ new Map();\n    for (const a of ((_a = atomState.m) == null ? void 0 : _a.t) || []) {\n      dependents.set(a, getAtomState(a, atomState));\n    }\n    for (const atomWithPendingPromise of atomState.p) {\n      dependents.set(\n        atomWithPendingPromise,\n        getAtomState(atomWithPendingPromise, atomState)\n      );\n    }\n    (_b = getPendingDependents(pending, atom)) == null ? void 0 : _b.forEach((dependent) => {\n      dependents.set(dependent, getAtomState(dependent, atomState));\n    });\n    return dependents;\n  };\n  const recomputeDependents = (pending, atom, atomState) => {\n    const topsortedAtoms = [];\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (a, aState) => {\n      if (markedAtoms.has(a)) {\n        return;\n      }\n      markedAtoms.add(a);\n      for (const [d, s] of getDependents(pending, a, aState)) {\n        if (a !== d) {\n          visit(d, s);\n        }\n      }\n      topsortedAtoms.push([a, aState, aState.n]);\n    };\n    visit(atom, atomState);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const [a, aState, prevEpochNumber] = topsortedAtoms[i];\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(pending, a, aState, isMarked);\n        mountDependencies(pending, a, aState);\n        if (prevEpochNumber !== aState.n) {\n          addPendingAtom(pending, a, aState);\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (pending, atom, atomState, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(pending, a, getAtomState(a, atomState)));\n    const setter = (a, ...args2) => {\n      const aState = getAtomState(a, atomState);\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const hasPrevValue = \"v\" in aState;\n        const prevValue = aState.v;\n        const v = args2[0];\n        setAtomStateValueOrPromise(a, aState, v);\n        mountDependencies(pending, a, aState);\n        if (!hasPrevValue || !Object.is(prevValue, aState.v)) {\n          addPendingAtom(pending, a, aState);\n          recomputeDependents(pending, a, aState);\n        }\n      } else {\n        r = writeAtomState(pending, a, aState, ...args2);\n      }\n      flushPending(pending);\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const pending = createPending();\n    const result = writeAtomState(pending, atom, getAtomState(atom), ...args);\n    flushPending(pending);\n    return result;\n  };\n  const mountDependencies = (pending, atom, atomState) => {\n    if (atomState.m && !isPendingPromise(atomState.v)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(pending, a, getAtomState(a, atomState));\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(pending, a, getAtomState(a, atomState));\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (pending, atom, atomState) => {\n    if (!atomState.m) {\n      readAtomState(pending, atom, atomState);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(pending, a, getAtomState(a, atomState));\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.add(atom);\n      }\n      if (isActuallyWritableAtom(atom) && atom.onMount) {\n        const mounted = atomState.m;\n        const { onMount } = atom;\n        addPendingFunction(pending, () => {\n          const onUnmount = onMount(\n            (...args) => writeAtomState(pending, atom, atomState, ...args)\n          );\n          if (onUnmount) {\n            mounted.u = onUnmount;\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (pending, atom, atomState) => {\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some(\n      (a) => {\n        var _a;\n        return (_a = getAtomState(a, atomState).m) == null ? void 0 : _a.d.has(atom);\n      }\n    )) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addPendingFunction(pending, onUnmount);\n      }\n      delete atomState.m;\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.delete(atom);\n      }\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(pending, a, getAtomState(a, atomState));\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const pending = createPending();\n    const atomState = getAtomState(atom);\n    const mounted = mountAtom(pending, atom, atomState);\n    flushPending(pending);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      const pending2 = createPending();\n      unmountAtom(pending2, atom, atomState);\n      flushPending(pending2);\n    };\n  };\n  const unstable_derive = (fn) => buildStore(...fn(getAtomState));\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom,\n    unstable_derive\n  };\n  if (( false ? 0 : void 0) !== \"production\") {\n    const devStore = {\n      // store dev methods (these are tentative and subject to change without notice)\n      dev4_get_internal_weak_map: () => ({\n        get: (atom) => {\n          const atomState = getAtomState(atom);\n          if (atomState.n === 0) {\n            return void 0;\n          }\n          return atomState;\n        }\n      }),\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\n      dev4_restore_atoms: (values) => {\n        const pending = createPending();\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            const atomState = getAtomState(atom);\n            const hasPrevValue = \"v\" in atomState;\n            const prevValue = atomState.v;\n            setAtomStateValueOrPromise(atom, atomState, value);\n            mountDependencies(pending, atom, atomState);\n            if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n              addPendingAtom(pending, atom, atomState);\n              recomputeDependents(pending, atom, atomState);\n            }\n          }\n        }\n        flushPending(pending);\n      }\n    };\n    Object.assign(store, devStore);\n  }\n  return store;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const getAtomState = (atom) => {\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  return buildStore(getAtomState);\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if (( false ? 0 : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vam90YWlAMi4xMC4wX0B0eXBlcytyZWFjdEAxOC4zLjExX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0EsY0FBYyxNQUFlLEdBQUcsQ0FBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVLE1BQWUsR0FBRyxDQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYSxNQUFlLEdBQUcsQ0FBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBZSxHQUFHLENBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBZSxHQUFHLENBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQWUsR0FBRyxDQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGlsaW5ndWFsLWFwcC8uL25vZGVfbW9kdWxlcy8ucG5wbS9qb3RhaUAyLjEwLjBfQHR5cGVzK3JlYWN0QDE4LjMuMTFfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vdmFuaWxsYS5tanM/OGU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQga2V5Q291bnQgPSAwO1xuZnVuY3Rpb24gYXRvbShyZWFkLCB3cml0ZSkge1xuICBjb25zdCBrZXkgPSBgYXRvbSR7KytrZXlDb3VudH1gO1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5kZWJ1Z0xhYmVsID8ga2V5ICsgXCI6XCIgKyB0aGlzLmRlYnVnTGFiZWwgOiBrZXk7XG4gICAgfVxuICB9O1xuICBpZiAodHlwZW9mIHJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbmZpZy5yZWFkID0gcmVhZDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuaW5pdCA9IHJlYWQ7XG4gICAgY29uZmlnLnJlYWQgPSBkZWZhdWx0UmVhZDtcbiAgICBjb25maWcud3JpdGUgPSBkZWZhdWx0V3JpdGU7XG4gIH1cbiAgaWYgKHdyaXRlKSB7XG4gICAgY29uZmlnLndyaXRlID0gd3JpdGU7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkKGdldCkge1xuICByZXR1cm4gZ2V0KHRoaXMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlKGdldCwgc2V0LCBhcmcpIHtcbiAgcmV0dXJuIHNldChcbiAgICB0aGlzLFxuICAgIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiA/IGFyZyhnZXQodGhpcykpIDogYXJnXG4gICk7XG59XG5cbmNvbnN0IGlzU2VsZkF0b20gPSAoYXRvbSwgYSkgPT4gYXRvbS51bnN0YWJsZV9pcyA/IGF0b20udW5zdGFibGVfaXMoYSkgOiBhID09PSBhdG9tO1xuY29uc3QgaGFzSW5pdGlhbFZhbHVlID0gKGF0b20pID0+IFwiaW5pdFwiIGluIGF0b207XG5jb25zdCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tID0gKGF0b20pID0+ICEhYXRvbS53cml0ZTtcbmNvbnN0IGNhbmNlbGFibGVQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpc1BlbmRpbmdQcm9taXNlID0gKHZhbHVlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIGlzUHJvbWlzZUxpa2UodmFsdWUpICYmICEoKF9hID0gY2FuY2VsYWJsZVByb21pc2VNYXAuZ2V0KHZhbHVlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzFdKTtcbn07XG5jb25zdCBjYW5jZWxQcm9taXNlID0gKHByb21pc2UsIG5leHRWYWx1ZSkgPT4ge1xuICBjb25zdCBwcm9taXNlU3RhdGUgPSBjYW5jZWxhYmxlUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG4gIGlmIChwcm9taXNlU3RhdGUpIHtcbiAgICBwcm9taXNlU3RhdGVbMV0gPSB0cnVlO1xuICAgIHByb21pc2VTdGF0ZVswXS5mb3JFYWNoKChmbikgPT4gZm4obmV4dFZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQnVnXSBjYW5jZWxhYmxlIHByb21pc2Ugbm90IGZvdW5kXCIpO1xuICB9XG59O1xuY29uc3QgcGF0Y2hQcm9taXNlRm9yQ2FuY2VsYWJpbGl0eSA9IChwcm9taXNlKSA9PiB7XG4gIGlmIChjYW5jZWxhYmxlUHJvbWlzZU1hcC5oYXMocHJvbWlzZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvbWlzZVN0YXRlID0gWy8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGZhbHNlXTtcbiAgY2FuY2VsYWJsZVByb21pc2VNYXAuc2V0KHByb21pc2UsIHByb21pc2VTdGF0ZSk7XG4gIGNvbnN0IHNldHRsZSA9ICgpID0+IHtcbiAgICBwcm9taXNlU3RhdGVbMV0gPSB0cnVlO1xuICB9O1xuICBwcm9taXNlLnRoZW4oc2V0dGxlLCBzZXR0bGUpO1xuICBwcm9taXNlLm9uQ2FuY2VsID0gKGZuKSA9PiB7XG4gICAgcHJvbWlzZVN0YXRlWzBdLmFkZChmbik7XG4gIH07XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQgPSAoYXRvbVN0YXRlKSA9PiBcInZcIiBpbiBhdG9tU3RhdGUgfHwgXCJlXCIgaW4gYXRvbVN0YXRlO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2XCIgaW4gYXRvbVN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gc3RhdGUgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG4gIHJldHVybiBhdG9tU3RhdGUudjtcbn07XG5jb25zdCBhZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeSA9IChhdG9tLCBwcm9taXNlLCBkZXBlbmRlbmN5QXRvbVN0YXRlKSA9PiB7XG4gIGlmICghZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmhhcyhhdG9tKSkge1xuICAgIGRlcGVuZGVuY3lBdG9tU3RhdGUucC5hZGQoYXRvbSk7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5QXRvbVN0YXRlLnAuZGVsZXRlKGF0b20pO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59O1xuY29uc3QgYWRkRGVwZW5kZW5jeSA9IChwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUsIGEsIGFTdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhID09PSBhdG9tKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0J1Z10gYXRvbSBjYW5ub3QgZGVwZW5kIG9uIGl0c2VsZlwiKTtcbiAgfVxuICBhdG9tU3RhdGUuZC5zZXQoYSwgYVN0YXRlLm4pO1xuICBpZiAoaXNQZW5kaW5nUHJvbWlzZShhdG9tU3RhdGUudikpIHtcbiAgICBhZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeShhdG9tLCBhdG9tU3RhdGUudiwgYVN0YXRlKTtcbiAgfVxuICAoX2EgPSBhU3RhdGUubSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnQuYWRkKGF0b20pO1xuICBpZiAocGVuZGluZykge1xuICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQocGVuZGluZywgYSwgYXRvbSk7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVQZW5kaW5nID0gKCkgPT4gWy8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldO1xuY29uc3QgYWRkUGVuZGluZ0F0b20gPSAocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gIGlmICghcGVuZGluZ1swXS5oYXMoYXRvbSkpIHtcbiAgICBwZW5kaW5nWzBdLnNldChhdG9tLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICBwZW5kaW5nWzFdLnNldChhdG9tLCBhdG9tU3RhdGUpO1xufTtcbmNvbnN0IGFkZFBlbmRpbmdEZXBlbmRlbnQgPSAocGVuZGluZywgYXRvbSwgZGVwZW5kZW50KSA9PiB7XG4gIGNvbnN0IGRlcGVuZGVudHMgPSBwZW5kaW5nWzBdLmdldChhdG9tKTtcbiAgaWYgKGRlcGVuZGVudHMpIHtcbiAgICBkZXBlbmRlbnRzLmFkZChkZXBlbmRlbnQpO1xuICB9XG59O1xuY29uc3QgZ2V0UGVuZGluZ0RlcGVuZGVudHMgPSAocGVuZGluZywgYXRvbSkgPT4gcGVuZGluZ1swXS5nZXQoYXRvbSk7XG5jb25zdCBhZGRQZW5kaW5nRnVuY3Rpb24gPSAocGVuZGluZywgZm4pID0+IHtcbiAgcGVuZGluZ1syXS5hZGQoZm4pO1xufTtcbmNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nKSA9PiB7XG4gIHdoaWxlIChwZW5kaW5nWzFdLnNpemUgfHwgcGVuZGluZ1syXS5zaXplKSB7XG4gICAgcGVuZGluZ1swXS5jbGVhcigpO1xuICAgIGNvbnN0IGF0b21TdGF0ZXMgPSBuZXcgU2V0KHBlbmRpbmdbMV0udmFsdWVzKCkpO1xuICAgIHBlbmRpbmdbMV0uY2xlYXIoKTtcbiAgICBjb25zdCBmdW5jdGlvbnMgPSBuZXcgU2V0KHBlbmRpbmdbMl0pO1xuICAgIHBlbmRpbmdbMl0uY2xlYXIoKTtcbiAgICBhdG9tU3RhdGVzLmZvckVhY2goKGF0b21TdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGF0b21TdGF0ZS5tKSA9PSBudWxsID8gdm9pZCAwIDogX2EubC5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9ucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbn07XG5jb25zdCBidWlsZFN0b3JlID0gKGdldEF0b21TdGF0ZSkgPT4ge1xuICBsZXQgZGVidWdNb3VudGVkQXRvbXM7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGRlYnVnTW91bnRlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBjb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCBhdG9tU3RhdGUsIHZhbHVlT3JQcm9taXNlKSA9PiB7XG4gICAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYXRvbVN0YXRlO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGF0b21TdGF0ZS52O1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlID0gaXNQZW5kaW5nUHJvbWlzZShhdG9tU3RhdGUudikgPyBhdG9tU3RhdGUudiA6IG51bGw7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICBwYXRjaFByb21pc2VGb3JDYW5jZWxhYmlsaXR5KHZhbHVlT3JQcm9taXNlKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3koXG4gICAgICAgICAgYXRvbSxcbiAgICAgICAgICB2YWx1ZU9yUHJvbWlzZSxcbiAgICAgICAgICBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLnYgPSB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgIGRlbGV0ZSBhdG9tU3RhdGUuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXRvbVN0YXRlLnYgPSB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgIGRlbGV0ZSBhdG9tU3RhdGUuZTtcbiAgICB9XG4gICAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGF0b21TdGF0ZS52KSkge1xuICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKHBlbmRpbmdQcm9taXNlLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKHBlbmRpbmcsIGF0b20sIGF0b21TdGF0ZSwgZm9yY2UpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoZm9yY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcmNlKGF0b20pKSAmJiBpc0F0b21TdGF0ZUluaXRpYWxpemVkKGF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChhdG9tU3RhdGUubSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KFxuICAgICAgICAoW2EsIG5dKSA9PiAoXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHksIHJlYWQgdGhlIGF0b20gc3RhdGUgb2YgdGhlIGRlcGVuZGVuY3ksIGFuZFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdG9tIGVwb2NoIG51bWJlciBpcyB1bmNoYW5nZWRcbiAgICAgICAgICByZWFkQXRvbVN0YXRlKHBlbmRpbmcsIGEsIGdldEF0b21TdGF0ZShhLCBhdG9tU3RhdGUpLCBmb3JjZSkubiA9PT0gblxuICAgICAgICApXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGF0b21TdGF0ZS5kLmNsZWFyKCk7XG4gICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGNvbnN0IGFTdGF0ZTIgPSBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKTtcbiAgICAgICAgaWYgKCFpc0F0b21TdGF0ZUluaXRpYWxpemVkKGFTdGF0ZTIpKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYSwgYVN0YXRlMiwgYS5pbml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgYSxcbiAgICAgICAgZ2V0QXRvbVN0YXRlKGEsIGF0b21TdGF0ZSksXG4gICAgICAgIGZvcmNlXG4gICAgICApO1xuICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICBhZGREZXBlbmRlbmN5KHBlbmRpbmcsIGF0b20sIGF0b21TdGF0ZSwgYSwgYVN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcyID0gY3JlYXRlUGVuZGluZygpO1xuICAgICAgICBhZGREZXBlbmRlbmN5KHBlbmRpbmcyLCBhdG9tLCBhdG9tU3RhdGUsIGEsIGFTdGF0ZSk7XG4gICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKHBlbmRpbmcyLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICBmbHVzaFBlbmRpbmcocGVuZGluZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUpO1xuICAgIH07XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgbGV0IHNldFNlbGY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgfSxcbiAgICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVhZC1vbmx5IGF0b21cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXRTZWxmICYmIGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBzZXRTZWxmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGluIHN5bmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFNlbGY7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWVPclByb21pc2UgPSBhdG9tLnJlYWQoZ2V0dGVyLCBvcHRpb25zKTtcbiAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGF0b20sIGF0b21TdGF0ZSwgdmFsdWVPclByb21pc2UpO1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICAgIChfYSA9IHZhbHVlT3JQcm9taXNlLm9uQ2FuY2VsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZU9yUHJvbWlzZSwgKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGF0b21TdGF0ZS5tKSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nMiA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKHBlbmRpbmcyLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlT3JQcm9taXNlLnRoZW4oY29tcGxldGUsIGNvbXBsZXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlbGV0ZSBhdG9tU3RhdGUudjtcbiAgICAgIGF0b21TdGF0ZS5lID0gZXJyb3I7XG4gICAgICArK2F0b21TdGF0ZS5uO1xuICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbSA9IChhdG9tKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZSh2b2lkIDAsIGF0b20sIGdldEF0b21TdGF0ZShhdG9tKSkpO1xuICBjb25zdCBnZXREZXBlbmRlbnRzID0gKHBlbmRpbmcsIGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGVwZW5kZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBhIG9mICgoX2EgPSBhdG9tU3RhdGUubSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnQpIHx8IFtdKSB7XG4gICAgICBkZXBlbmRlbnRzLnNldChhLCBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXRvbVdpdGhQZW5kaW5nUHJvbWlzZSBvZiBhdG9tU3RhdGUucCkge1xuICAgICAgZGVwZW5kZW50cy5zZXQoXG4gICAgICAgIGF0b21XaXRoUGVuZGluZ1Byb21pc2UsXG4gICAgICAgIGdldEF0b21TdGF0ZShhdG9tV2l0aFBlbmRpbmdQcm9taXNlLCBhdG9tU3RhdGUpXG4gICAgICApO1xuICAgIH1cbiAgICAoX2IgPSBnZXRQZW5kaW5nRGVwZW5kZW50cyhwZW5kaW5nLCBhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGRlcGVuZGVudCkgPT4ge1xuICAgICAgZGVwZW5kZW50cy5zZXQoZGVwZW5kZW50LCBnZXRBdG9tU3RhdGUoZGVwZW5kZW50LCBhdG9tU3RhdGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVwZW5kZW50cztcbiAgfTtcbiAgY29uc3QgcmVjb21wdXRlRGVwZW5kZW50cyA9IChwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IFtdO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChhLCBhU3RhdGUpID0+IHtcbiAgICAgIGlmIChtYXJrZWRBdG9tcy5oYXMoYSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya2VkQXRvbXMuYWRkKGEpO1xuICAgICAgZm9yIChjb25zdCBbZCwgc10gb2YgZ2V0RGVwZW5kZW50cyhwZW5kaW5nLCBhLCBhU3RhdGUpKSB7XG4gICAgICAgIGlmIChhICE9PSBkKSB7XG4gICAgICAgICAgdmlzaXQoZCwgcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2goW2EsIGFTdGF0ZSwgYVN0YXRlLm5dKTtcbiAgICB9O1xuICAgIHZpc2l0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgY29uc3QgY2hhbmdlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKTtcbiAgICBjb25zdCBpc01hcmtlZCA9IChhKSA9PiBtYXJrZWRBdG9tcy5oYXMoYSk7XG4gICAgZm9yIChsZXQgaSA9IHRvcHNvcnRlZEF0b21zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBbYSwgYVN0YXRlLCBwcmV2RXBvY2hOdW1iZXJdID0gdG9wc29ydGVkQXRvbXNbaV07XG4gICAgICBsZXQgaGFzQ2hhbmdlZERlcHMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGFTdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBpZiAoZGVwICE9PSBhICYmIGNoYW5nZWRBdG9tcy5oYXMoZGVwKSkge1xuICAgICAgICAgIGhhc0NoYW5nZWREZXBzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWREZXBzKSB7XG4gICAgICAgIHJlYWRBdG9tU3RhdGUocGVuZGluZywgYSwgYVN0YXRlLCBpc01hcmtlZCk7XG4gICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKHBlbmRpbmcsIGEsIGFTdGF0ZSk7XG4gICAgICAgIGlmIChwcmV2RXBvY2hOdW1iZXIgIT09IGFTdGF0ZS5uKSB7XG4gICAgICAgICAgYWRkUGVuZGluZ0F0b20ocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgICBjaGFuZ2VkQXRvbXMuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXJrZWRBdG9tcy5kZWxldGUoYSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUocGVuZGluZywgYSwgZ2V0QXRvbVN0YXRlKGEsIGF0b21TdGF0ZSkpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhLCBhdG9tU3RhdGUpO1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBpZiAoIWhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0b20gbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFwidlwiIGluIGFTdGF0ZTtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gYVN0YXRlLnY7XG4gICAgICAgIGNvbnN0IHYgPSBhcmdzMlswXTtcbiAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYSwgYVN0YXRlLCB2KTtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGFTdGF0ZS52KSkge1xuICAgICAgICAgIGFkZFBlbmRpbmdBdG9tKHBlbmRpbmcsIGEsIGFTdGF0ZSk7XG4gICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhwZW5kaW5nLCBhLCBhU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gd3JpdGVBdG9tU3RhdGUocGVuZGluZywgYSwgYVN0YXRlLCAuLi5hcmdzMik7XG4gICAgICB9XG4gICAgICBmbHVzaFBlbmRpbmcocGVuZGluZyk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF0b20ud3JpdGUoZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICBjb25zdCByZXN1bHQgPSB3cml0ZUF0b21TdGF0ZShwZW5kaW5nLCBhdG9tLCBnZXRBdG9tU3RhdGUoYXRvbSksIC4uLmFyZ3MpO1xuICAgIGZsdXNoUGVuZGluZyhwZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IChwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICBpZiAoYXRvbVN0YXRlLm0gJiYgIWlzUGVuZGluZ1Byb21pc2UoYXRvbVN0YXRlLnYpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLm0uZC5oYXMoYSkpIHtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50QXRvbShwZW5kaW5nLCBhLCBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKSk7XG4gICAgICAgICAgYU1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICAgICAgYXRvbVN0YXRlLm0uZC5hZGQoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUubS5kIHx8IFtdKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLmQuaGFzKGEpKSB7XG4gICAgICAgICAgYXRvbVN0YXRlLm0uZC5kZWxldGUoYSk7XG4gICAgICAgICAgY29uc3QgYU1vdW50ZWQgPSB1bm1vdW50QXRvbShwZW5kaW5nLCBhLCBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKSk7XG4gICAgICAgICAgYU1vdW50ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGFNb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEF0b20gPSAocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgaWYgKCFhdG9tU3RhdGUubSkge1xuICAgICAgcmVhZEF0b21TdGF0ZShwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50QXRvbShwZW5kaW5nLCBhLCBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKSk7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLm0gPSB7XG4gICAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIGQ6IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKSxcbiAgICAgICAgdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBkZWJ1Z01vdW50ZWRBdG9tcy5hZGQoYXRvbSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IGF0b21TdGF0ZS5tO1xuICAgICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICAgIGFkZFBlbmRpbmdGdW5jdGlvbihwZW5kaW5nLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudChcbiAgICAgICAgICAgICguLi5hcmdzKSA9PiB3cml0ZUF0b21TdGF0ZShwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUsIC4uLmFyZ3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICBtb3VudGVkLnUgPSBvblVubW91bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0b21TdGF0ZS5tO1xuICB9O1xuICBjb25zdCB1bm1vdW50QXRvbSA9IChwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICBpZiAoYXRvbVN0YXRlLm0gJiYgIWF0b21TdGF0ZS5tLmwuc2l6ZSAmJiAhQXJyYXkuZnJvbShhdG9tU3RhdGUubS50KS5zb21lKFxuICAgICAgKGEpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gZ2V0QXRvbVN0YXRlKGEsIGF0b21TdGF0ZSkubSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuaGFzKGF0b20pO1xuICAgICAgfVxuICAgICkpIHtcbiAgICAgIGNvbnN0IG9uVW5tb3VudCA9IGF0b21TdGF0ZS5tLnU7XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIGFkZFBlbmRpbmdGdW5jdGlvbihwZW5kaW5nLCBvblVubW91bnQpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGF0b21TdGF0ZS5tO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRlYnVnTW91bnRlZEF0b21zLmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSB1bm1vdW50QXRvbShwZW5kaW5nLCBhLCBnZXRBdG9tU3RhdGUoYSwgYXRvbVN0YXRlKSk7XG4gICAgICAgIGFNb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBhTW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhdG9tU3RhdGUubTtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlQXRvbSA9IChhdG9tLCBsaXN0ZW5lcikgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVQZW5kaW5nKCk7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudEF0b20ocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKTtcbiAgICBmbHVzaFBlbmRpbmcocGVuZGluZyk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGNvbnN0IHBlbmRpbmcyID0gY3JlYXRlUGVuZGluZygpO1xuICAgICAgdW5tb3VudEF0b20ocGVuZGluZzIsIGF0b20sIGF0b21TdGF0ZSk7XG4gICAgICBmbHVzaFBlbmRpbmcocGVuZGluZzIpO1xuICAgIH07XG4gIH07XG4gIGNvbnN0IHVuc3RhYmxlX2Rlcml2ZSA9IChmbikgPT4gYnVpbGRTdG9yZSguLi5mbihnZXRBdG9tU3RhdGUpKTtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b20sXG4gICAgdW5zdGFibGVfZGVyaXZlXG4gIH07XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGRldlN0b3JlID0ge1xuICAgICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgICAgZGV2NF9nZXRfaW50ZXJuYWxfd2Vha19tYXA6ICgpID0+ICh7XG4gICAgICAgIGdldDogKGF0b20pID0+IHtcbiAgICAgICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgICAgaWYgKGF0b21TdGF0ZS5uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGRldjRfZ2V0X21vdW50ZWRfYXRvbXM6ICgpID0+IGRlYnVnTW91bnRlZEF0b21zLFxuICAgICAgZGV2NF9yZXN0b3JlX2F0b21zOiAodmFsdWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVQZW5kaW5nKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2F0b20sIHZhbHVlXSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGF0b20pKSB7XG4gICAgICAgICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgICAgICBjb25zdCBoYXNQcmV2VmFsdWUgPSBcInZcIiBpbiBhdG9tU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBhdG9tU3RhdGUudjtcbiAgICAgICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGF0b20sIGF0b21TdGF0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgICAgIGlmICghaGFzUHJldlZhbHVlIHx8ICFPYmplY3QuaXMocHJldlZhbHVlLCBhdG9tU3RhdGUudikpIHtcbiAgICAgICAgICAgICAgYWRkUGVuZGluZ0F0b20ocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVzaFBlbmRpbmcocGVuZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHN0b3JlLCBkZXZTdG9yZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKCkgPT4ge1xuICBjb25zdCBhdG9tU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgZ2V0QXRvbVN0YXRlID0gKGF0b20pID0+IHtcbiAgICBsZXQgYXRvbVN0YXRlID0gYXRvbVN0YXRlTWFwLmdldChhdG9tKTtcbiAgICBpZiAoIWF0b21TdGF0ZSkge1xuICAgICAgYXRvbVN0YXRlID0geyBkOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBwOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuOiAwIH07XG4gICAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBhdG9tU3RhdGU7XG4gIH07XG4gIHJldHVybiBidWlsZFN0b3JlKGdldEF0b21TdGF0ZSk7XG59O1xubGV0IGRlZmF1bHRTdG9yZTtcbmNvbnN0IGdldERlZmF1bHRTdG9yZSA9ICgpID0+IHtcbiAgaWYgKCFkZWZhdWx0U3RvcmUpIHtcbiAgICBkZWZhdWx0U3RvcmUgPSBjcmVhdGVTdG9yZSgpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZ2xvYmFsVGhpcy5fX0pPVEFJX0RFRkFVTFRfU1RPUkVfXyB8fCAoZ2xvYmFsVGhpcy5fX0pPVEFJX0RFRkFVTFRfU1RPUkVfXyA9IGRlZmF1bHRTdG9yZSk7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5fX0pPVEFJX0RFRkFVTFRfU1RPUkVfXyAhPT0gZGVmYXVsdFN0b3JlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIEpvdGFpIGluc3RhbmNlcy4gSXQgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2l0aCB0aGUgZGVmYXVsdCBzdG9yZS4gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9qb3RhaS9kaXNjdXNzaW9ucy8yMDQ0XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTdG9yZTtcbn07XG5cbmV4cG9ydCB7IGF0b20sIGNyZWF0ZVN0b3JlLCBnZXREZWZhdWx0U3RvcmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/jotai@2.10.0_@types+react@18.3.11_react@18.3.1/node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;